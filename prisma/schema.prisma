// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id               String         @id @default(uuid())
  name             String
  email            String         @unique
  password_hash    String
  role             UserRole
  username  String?   @unique
  phone_number     String?
  logo  String?
  bio String?
  emailVerified      Boolean  @default(false)
  verificationToken  String?
  resetPasswordToken    String?  @unique
  resetPasswordExpires  DateTime?
   twoFactorEnabled    Boolean  @default(true)
  twoFactorCode       String?  // stores generated 2FA code temporarily
  twoFactorExpiresAt  DateTime? // expiry time for the 2FA code
  resetPasswordCode String?
  resetPasswordCodeExpiresAt DateTime?
  created_at       DateTime       @default(now())
  updated_at       DateTime       @updatedAt
  provider AuthProvider @default(CREDENTIALS)
  isDeleted  Boolean  @default(false)
  deletedAt DateTime? 
  saved_properties  Property[]     @relation("saved_properties")  
  // For Agents
  is_verified      Boolean        @default(false)
  verification_notes String?
  verification_docs Json?          // Changed to JSON
  properties       Property[]     @relation("user_properties") // properties this user owns (agent)
  address Json?
  socials Json?
  // New relations for leads
  submittedLeads   Lead[]         @relation("LeadSubmitter")  // leads this user submitted
  handledLeads     Lead[]         @relation("LeadHandler") 


  notifications Notification[]  
  

  saved_searches SavedSearch[]

  Subscriptions Subscription[]

  Payment Payment[]

  PaystackCustomer PaystackCustomer?

  agentReviews   AgentReview[] @relation("AgentReviewer")
  reviewsReceived AgentReview[] @relation("AgentReviewed")

  propertyReviews PropertyReview[]

  ActivityLog ActivityLog[]
}


model Property {
  id             String    @id @default(uuid())
  agent       User?      @relation("user_properties", fields: [agentId], references: [id])  
  agentId        String?
  title          String
  description    String
  bedrooms       String
  bathrooms      String
  toilets        String
  size_sqm       Float
  price          Float
  discount_percent Float?
  discounted_price Float?
  property_type  PropertyType
  listing_type   ListingType
  furnishing     Furnishing
  status         PropertyStatus
  amenities      String[]
  date_added     DateTime @default(now())
  date_modified  DateTime @updatedAt
  images         String[]
  street    String
  city      String
  state     String
  //TODO add postal code
  lat Float?
  lon Float?
  parking_spaces  String?
 saved_by     User[]    @relation("saved_properties")
  approval_status    ApprovalStatus @default(pending)
  approval_notes String?

//  For Rentals
  availability   String?
  tenancy_info String?
  service_charge String?
  min_tenancy String?
  deposit Float?

  leads Lead[]
   visibility VisibilityLevel @default(low)
   is_featured Boolean @default(false)
   reviews PropertyReview[]
}

model Lead {
  id          String    @id @default(uuid())
  property    Property? @relation(fields: [propertyId], references: [id])
  propertyId  String?
  
  // The user who submitted the lead (can be null if guest)
  user        User?     @relation("LeadSubmitter", fields: [userId], references: [id])
  userId      String?

  // The agent assigned to handle the lead (nullable until assigned)
  agent       User?     @relation("LeadHandler", fields: [agentId], references: [id])
  agentId     String?

  name        String?    
  // Name of lead (if guest, they can leave name). For now since user needs to be registered, then this is optional
  email       String?    // Email of lead Optional for now
  message     String   // Optional inquiry message
  status      LeadStatus @default(new)
  closure_reason String?

  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
}

model Notification {
  id          String   @id @default(uuid())
  recipient   User     @relation(fields: [recipientId], references: [id])
  recipientId String
  title       String   @default("")
  type        NotificationType @default(IN_APP)
  message     String   @default("")
  linkUrl     String?  // For in-app deep links (e.g., property, lead)
  metadata    Json?    // For extra data (e.g., { propertyId: 'uuid' })
  isRead      Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  //TODO ADD THIS LATER
  category        String?  // e.g., 'SUBSCRIPTION', 'PAYMENT'
  relatedEntityId String?  // Links to payment or subscription ID
  //   category String? // e.g., 'Lead', 'Property', 'SavedSearch'
  // action String? // e.g., 'created', 'matched', 'replied'

}

model SavedSearch {
  id          String   @id @default(uuid())
  user        User     @relation(fields: [userId], references: [id])
  userId      String

  name        String?          // optional label for UI, e.g., "Lagos Apartments"
  query       Json             // store query parameters (location, min/max price, etc.)
  sendAlerts  Boolean @default(false)  // whether to notify when new matching listings appear

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  last_checked DateTime @default(now())

  // optional: frequency, expiration, etc.

  SearchAlertLog SearchAlertLog[]
}

model SearchAlertLog {
   id          String   @id @default(uuid())
  search      SavedSearch @relation(fields: [searchId], references: [id])
  searchId    String
  userId      String   // redundant but useful for indexing/filtering

  result_count Int
  method       NotificationType // IN_APP or EMAIL
  notified_at  DateTime @default(now())
}

model SubscriptionTier {
  id       String   @id @default(uuid())
  name     SubscriptionTierType @unique
  features Json?
  description String?
  rank Int @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  subscriptions Subscription[]
  SubscriptionPlan SubscriptionPlan[]
}

model Subscription {
  id                      String   @id @default(uuid())
  agent                   User     @relation(fields: [agentId], references: [id])
  agentId                 String
  plan                    SubscriptionTier @relation(fields: [planId], references: [id])
  planId                  String
  startDate               DateTime
  endDate                 DateTime?
  isActive                Boolean  @default(true)
  manuallyGranted         Boolean  @default(false)

  // ðŸ§¾ Recurring Billing Metadata
  paystackPlanCode         String?     // From Paystack plan object
  paystackSubscriptionCode String? @unique    // From Paystack subscription object
  paystackCustomerCode     String?     // From Paystack customer (for future charges)
  paystackEmailToken       String?     // Used in confirmation URLs (optional)
  paystackInvoiceToken     String?     // Token for invoice view/download
  nextPaymentDate          DateTime?   // When next billing is due
  gracePeriodEndDate      DateTime? // This is the new field

  createdAt                DateTime @default(now())
  payments                 Payment[]
}

model PaystackCustomer {
  userId       String   @id
  customerCode String   @unique
  user         User     @relation(fields: [userId], references: [id])
}


model SubscriptionPlan {
  id        String            @id @default(uuid())
  tier      SubscriptionTier  @relation(fields: [tierId], references: [id])
  tierId    String
  duration  Duration
  price     Int
  createdAt DateTime          @default(now())
  paystackPlanCode String?
}

model Payment {
  id              String         @id @default(uuid())
  user            User           @relation(fields: [userId], references: [id])
  userId          String
  subscription    Subscription?  @relation(fields: [subscriptionId], references: [id])
  subscriptionId  String?
  amount          Int
  currency        String         @default("NGN")
  status          PaymentStatus  @default(PENDING)
  reference       String         @unique
  purpose         PaymentPurpose @default(SUBSCRIPTION)
  provider        PaymentProvider
  createdAt       DateTime       @default(now())
  updatedAt       DateTime?
}

model AgentReview {
  id          String   @id @default(uuid())
  reviewer    User     @relation("AgentReviewer", fields: [reviewerId], references: [id])
  reviewerId  String
  agent       User     @relation("AgentReviewed", fields: [agentId], references: [id])
  agentId     String
  rating      Int      // 1 to 5 stars
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model PropertyReview {
  id          String   @id @default(uuid())
  reviewer    User     @relation(fields: [reviewerId], references: [id])
  reviewerId  String
  property    Property @relation(fields: [propertyId], references: [id])
  propertyId  String
  rating      Int      // 1 to 5 stars
  comment     String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model ActivityLog {
  id          String            @id @default(uuid())
  userId      String?
  category    ActivityCategory
  action      String
  description String?
  ipAddress   String?
  userAgent   String?
  changes     Json?
  metadata    Json?
  createdAt   DateTime           @default(now())

  user User? @relation(fields: [userId], references: [id])
}

enum ActivityCategory {
  AUTH
  ACCOUNT
  USER_ACTION
  CRITICAL
  SYSTEM
  ADMIN_ACTION
}


enum PaymentStatus {
  PENDING
  SUCCESS
  FAILED
  REFUNDED
  COMPLIMENTARY
}

enum PaymentProvider {
  PAYSTACK
  // STRIPE
  FLUTTERWAVE
  MANUAL
}


enum NotificationType {
  IN_APP
  EMAIL
}


enum LeadStatus {
  new
  contacted
  in_progress
  closed
}

enum Duration {
  MONTHLY
  YEARLY
}

enum UserRole {
  buyer
  agent
  admin
}

enum PropertyType {
  apartment
  detached
  semi_detached
  terrace
  land
}

enum ListingType {
  sale
  rent
  shortlet
}

enum Furnishing {
  furnished
  unfurnished
  partly_furnished
}

enum PropertyStatus {
  available
  sold
  rented
  unavailable
}

enum SubscriptionTierType {
  basic
  premium
  enterprise
}
enum ApprovalStatus {
  approved
  pending
  rejected
}

enum VisibilityLevel {
  low     // For basic
  medium  // For premium
  high    // For enterprise
}

enum PaymentPurpose {
  SUBSCRIPTION
  PROPERTY_BOOST
  FEATURE_UPGRADE
  CUSTOM
}

enum AuthProvider{
  GOOGLE
  CREDENTIALS
}
